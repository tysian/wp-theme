import { PackageJson } from 'type-fest';
import { isEmpty, isObject, kebabCase } from 'lodash-es';
import chalk from 'chalk';
import { gitCheck } from '$/shared/utils/gitCheck.js';
import { FileExistenceError, fileExists, logger, readStream } from '$/shared/utils/index.js';
import { parseZodError } from '$/shared/utils/parseZodError.js';
import {
  StyleCss,
  StyleCssGeneratorOptions,
  styleCssSchema,
  styleCssSchemaWithRestrictedTagsSchema,
} from './create-style-css.config.js';

export const styleCssGenerator = async (options: StyleCssGeneratorOptions) => {
  logger.start('Generating style.css with meta information.');

  try {
    /**
     * - [x] check if package.json has `wp` | `wordpress` | `wp-theme-cli` property
     * - [x] validate package.json `wp` property using Zod
     *    - [x] respect `--use-restricted-tags` option
     * - [ ] check if style.css exists in CWD
     * - [ ] if there is an `--dont-overwrite` option, then throw Error
     * - [ ] check if style.css has comments using CSSTree
     * - [ ] assume that first comment is a meta description
     * - [ ] update first comment by new data generated from `package.json`
     * - [ ] add `generated by wp-theme-cli + current date
     * - [ ] save new style.css
     */

    const { validateSchema = false, useRestricted = false } = options;

    // Check git
    await gitCheck();

    // Check if package.json exists in CWD
    const PKG_PATH = './package.json';
    const pkgExists = fileExists(PKG_PATH);
    if (!pkgExists) throw new FileExistenceError(PKG_PATH);

    // Read package.json and check if it has any of the necessary keys
    const pkg: PackageJson & Record<'wp' | 'wordpress' | 'wp-theme-cli', StyleCss> =
      await readStream(PKG_PATH).then(JSON.parse);
    const pkgWp = pkg?.wp ?? pkg?.wordpress ?? pkg?.['wp-theme-cli'] ?? {};

    if (pkgWp?.version) {
      logger.warn(
        `Found theme version. Version will be replaced by ${chalk.italic('package.json')} version.`
      );
    }

    // Inherit properties from package.json
    pkgWp.theme_name = pkgWp.theme_name || pkg.name || '';
    pkgWp.theme_uri = pkgWp.theme_uri || pkg.homepage || '';
    pkgWp.author =
      pkgWp.author || (typeof pkg.author === 'string' ? pkg.author : pkg.author?.name) || '';
    pkgWp.author_uri =
      pkgWp.author_uri || (typeof pkg.author === 'object' && pkg.author?.url) || '';
    pkgWp.description = pkgWp.description || pkg.description || '';
    pkgWp.license = pkgWp.license || pkg.license || '';
    pkgWp.text_domain = pkgWp.text_domain || kebabCase(pkg.name ?? '') || 'theme';

    if (validateSchema) {
      if (isObject(pkgWp) && isEmpty(pkgWp)) {
        // empty
      }

      const schema = useRestricted ? styleCssSchemaWithRestrictedTagsSchema : styleCssSchema;
      const parsed = schema.safeParse(pkgWp);
      if (!parsed.success) {
        logger.error(parseZodError(parsed.error));
      }
    }

    pkgWp.version = pkg.version || '0.0.1';
  } catch (error) {
    logger.error((error as Error)?.message);
  }
};
